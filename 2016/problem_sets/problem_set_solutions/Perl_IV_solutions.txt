Perl IV Problem Set
==================
1. Iterate through each element of this array using a foreach loop: (101,2,15,22,95,33,2,27,72,15,52);
   - Print out only the values that are even (use modulus operator).


+---------------------------+
#!/usr/bin/perl
# File: iterate.pl
# Author: Steven Ahrendt

use strict;                                                                                                                                                                       
use warnings;

my @numbers = (101, 2, 15, 22, 95, 33, 2, 27, 72, 15, 52);

foreach my $number (@numbers)
{
  if($number % 2 ==0) # The modulus operator is a simple way 
  {                   # to get even values
    print "$number\n";
  }
}
+---------------------------+



2. Iterate through each element in the the above array using a for loop.
   - Print only the values of the indices that are odd  

+---------------------------+
#!/usr/bin/perl
# File: forLoop.pl
# Author: Steven Ahrendt

use strict;
use warnings;

my @numbers = (101, 2, 15, 22, 95, 33, 2, 27, 72, 15, 52);
for (my $i = 0; $i < scalar(@numbers); $i++)
{
  if($i%2 != 0)
  {
    print "$numbers[$i]\n";
  }
}
+---------------------------+


3. Using the sort() function with the above array
   - Sort the array with the default sort function and store the new sorted array.
   - print out the array. Are they sorted numerically?
   - customize the sort function to sort the numbers numerically, and store the new sorted array.
   - print out the array. Are they sorted numerically?
   - reverse the numeric sort (hint, switch $a and $b), and store the new sorted array.
   - print out the array. Are they sorted numerically, biggest to smallest?


+---------------------------+
#!/usr/bin/perl                                                                                                                                                                                      
# File: sortNumbers.pl
# Author: Steven Ahrendt

use strict;
use warnings;

my @numbers = (101, 2, 15, 22, 95, 33, 2, 27, 72, 15, 52);

## Sort using default sort:
my @sorted_default = sort @numbers;
print "Default:\n"
print join("\n",@sorted_default),"\n";  ## anything can be a delimiter in join,
                                        #   so here I'm using the newline character

## Sort using numeric sort:
my @sorted_numeric = sort { $a <=> $b } @numbers;
print "Numeric:\n";
print join("\n",@sorted_numeric),"\n";

## Sort using reverse numeric sort:
print "Reverse numeric:\n";
my @sorted_revNumeric = sort { $b <=> $a } @numbers;
print join("\n",@sorted_revNumeric),"\n";
+---------------------------+



4. Iterate through each of the elements of the above array, but sort them numerically.
   - Print each element.
   - Create two cumulative sums, one of all the even values and one of all the odd values. 
   - Print the two sums.


+---------------------------+
#!/usr/bin/perl
# File: iterateSort.pl
# Author: Steven Ahrendt

use warnings;
use strict;

my @numbers = (101, 2, 15, 22, 95, 33, 2, 27, 72, 15, 52);
my $even_sum = 0;
my $odd_sum = 0;

## Use the so-called "spaceship operator" ('<=>') to compare two numbers.
#   The sort() function operates on the abstract variables $a and $b.
#   These are special variables in Perl, so it's best to avoid creating
#   our own variables with those names.
foreach my $item (sort {$a <=> $b} @numbers)
{
  print $item,"\n";  # print each element
  if($item % 2 == 0)
  {
    ## "$something += $something_else" is a shorthand way
    #    of writing "$something = $something+$something_else"
    $even_sum += $item; 
  }
  else
  {
    $odd_sum += $item;
  }
}
+---------------------------+



5. Using pop, push, shift, unshift with the array
   - use pop on this array. Store the result of pop in a variable. Print the contents of this variable. Print the array. How is the array different from before the use of pop?
   - use shift on the original array. Store the result of shift in a variable. Print the contents of this variable. Print the array. How is the array different from before the use of shift?
   - use push on the original array with the number 12. Print the array. How is the array different from before the use of push?
   - use unshift on the original array with the number 4. Print the array. How is the array different from before the use of unshift?



+---------------------------+
#!/usr/bin/perl                                                                                                                                                                                   
# File: arrayManip.pl
# Author: Steven Ahrendt

use strict;
use warnings;

my @numbers = (101, 2, 15, 22, 95, 33, 2, 27, 72, 15, 52);

## Use the pop() function, store the result, and print the array
my $pop_result = pop @array;
print "Pop variable: $pop_result\n";
print "Array after pop(): ",join(" ", @array),"\n";

## Use the shift() function, store the result, and print the array
my $shift_result = shift(@array);
print "Shift variable: $shift_result\n";
print "Array after shift(): ",join(" ", @array),"\n";

## Use push() with the number 12 and print the array
my $push_variable = 12;
push(@array, $push_variable);
print "Array after push(): ",join(" ", @array),"\n";

## Use unshift() with the number 4 and print the array
my $unshift_variable = 4;
unshift(@array, $unshift_variable);
print "Array after unshift(): ",join(" ", @array),"\n";
+---------------------------+



6.  Run this code. Is its output what you expect? Why?
                  for (my $i = 0; $i < 10; $i++) {
                   if ($i = 2) {
                       print "\$i = $i\n";
                   }
                  }


+---------------------------+
The expectation because of the for loop is:

$i = 2

only when the scalar $i is equal to 2. There
should be no output otherwise.

Instead, we encounter an infinite loop because we are
always assigning 2 to $i, meaning we will never exit the loop
because $i will never be equal to 10.
+---------------------------+
Also, try running this script with the perl debugger!
+---------------------------+


7. Using the sort function with strings: use this array: ('ATGCCCGGCCCGGC','GCGTGCTAGCAATACGATAAACCGG', 'ATATATATCGAT','ATGGGCCC') 

+---------------------------+
#!/usr/bin/perl                                                                                                  
# File: sortSeq.pl
# Author: Steven Ahrendt

use strict;
use warnings;

my @fragments = ('ATGCCCGGCCCGGC','GCGTGCTAGCAATACGATAAACCGG', 'ATATATATCGAT','ATGGGCCC');

## Largest to smallest
print("Largest to smallest\n");
my @sorted_fragments = sort {length($b) <=> length($a) } @fragments;
print join("\n",@sorted_fragments),"\n";

print "\n\n\n";

## Smallest to largest: change the order of $a and $b
print("Smallest to largest\n");
my @sorted_fragments_rev = sort {length($a) <=> length($b) } @fragments;
print join("\n",@sorted_fragments_rev),"\n";

+---------------------------+

8. Calculate GC content of one sequence
   Turn a ONE of the above DNA strings into an array with split()
   Use a foreach loop to look at each nucleotide in turn
   Calculate total length of the sequence
   Keep a running total of C's and G's
   Print the calculated GC content as a percent.

+---------------------------+
#!/usr/bin/perl                                                                                                  
# File: GC_calc.pl
# Author: Steven Ahrendt

use strict;
use warnings;

my @fragments = ('ATGCCCGGCCCGGC','GCGTGCTAGCAATACGATAAACCGG', 'ATATATATCGAT','ATGGGCCC');

my $sequence = shift @fragments; # just get the first sequence

my @nt_array = split(//,$sequence);  # use // to split each character

my $total_length=0;
my $total_G=0;
my $total_C=0;
foreach my $nt (@nt_array)
{
  if($nt eq "C")
  {
    $total_C++;
  }
  if($nt eq "G")
  {
    $total_G++;
  }
  $total_length++;
}

my $total_GC = $total_G + $total_C;

printf("GC percent: %.2f%%\n",($total_GC/$total_length)*100);
+---------------------------+


9. Place your GC content calculator code into a loop, and calculate the GC content of each of the sequences in the above array. 


+---------------------------+
#!/usr/bin/perl                                                                                                  
# File: GC_calcLoop.pl
# Author: Steven Ahrendt

use strict;
use warnings;

my @fragments = ('ATGCCCGGCCCGGC','GCGTGCTAGCAATACGATAAACCGG', 'ATATATATCGAT','ATGGGCCC');

foreach my $sequence (@fragments)
{
  my @nt_array = split(//,$sequence);  # use // to split each character

  my $total_length=0;
  my $total_G=0;
  my $total_C=0;
  foreach my $nt (@nt_array)
  {
    if($nt eq "C")
    {
      $total_C++;
    }
    if($nt eq "G")
    {
      $total_G++;
    }
    $total_length++;
  }

  my $total_GC = $total_G + $total_C;

  printf("GC percent: %.2f%%\n",($total_GC/$total_length)*100);
}
+---------------------------+

10. Create a shuffled sequence
  Turn a DNA string into an array with split()
  Use a for loop to perform the following procedure N times (N = length of seq)
    Select a random position A with rand()
    Select a random position B with rand()
    Exchange the letters at array indices A and B
    (remember you can reassign any value in an array: $array[4] = "new value";)
  Print the now shuffled sequence


+---------------------------+
#!/usr/bin/perl
# File: shuffle.pl
# Author: Steven Ahrendt

use warnings;
use strict;

my $sequence = 'ATGCCCGGCCCGGC';
my @nt_array = split(//, $sequence);

my $seq_length = length ($sequence);  # or = scalar(@nucleotides)                                                                                                                                         
for (my $i = 0; $i < $seq_length; $i++)
{
  ## The rand() function retruns a decimal value, but we want 
  #    an integer to use as an index. So we use another function
  #    int() to convert the output of rand() to something we can use
  my $index1 = int(rand ($seq_length));
  my $index2 = int(rand ($seq_length));

  ## The cautious way to reassign variables in an array is to use a temp variable:
  my $tmp = $nt_array[$index1];
  $nt_array[$index1] = $nt_array[$index2];

  ## Now we have to use the $tmp value since we've overwritten the $index1 value
  $nt_array[$index2] = $tmp;

  ## However, Perl also allows the following:
  #  ($nt_array[$index1],$nt_array[$index2]) = ($nt_array[$index2],$nt_array[$index1])
  #  A practical example of this is sorting.
}
print "Original: $sequence\n";
print "Shuffled: ",join("", @nt_array),"\n";
+---------------------------+

 
11a. Start with 2 very similar DNA sequences. 
  Align with ClustalW, TCoffee, or some other web alignment application. 
  Output should be in FASTA format.
  Store (copy and paste) the sequence, including dashes, from each ClustalW fasta output in a separate string variable inside your script.
  Turn each string into an array with split()
  Use a for loop to compare each index for nucleotide differences.
  Report the nucleotide position of each difference.

+---------------------------+
#!/usr/bin/perl
# File: alignment.pl
# Author: Steven Ahrendt

use strict;
use warnings;

my $al_seq1 = "-------------------------------------------------------------------------------------AGCACCCTCCCACCTCATCCCACCCTTCTGATCTCAATCCAACGTCGCATCTCCAC-CGTCTCGCGGA----TCGACCCAGCGAAGTCCCTC----CCGCCCCCAAAGTCCCCCAAATCTTGCAGTTCCCTCCTAAATCCTCCCCA------------TATAAACCAACCCCCCGCCCTCAGATCCC-TAATCCCATCGCAAGCA--TCAGACTCCCTCCAAAGCAGGCAGCAGCTCCTCTTCTTCCTAATCACACTATCTCGGAGAGGAGCGGCCATGTCTGGGCGCGACAAGGGCGGCAAGGGGCTGGGCAAGGGCGGCGCCAAGCGGCACCGGAAGGTCCTCCGCGACAACATCCAGGGCATCACCAAGCCGGCGATCCGGAGGCTGGCCAGGAGGGGCGGCGTGAAGCGCATCTCCGGCCTCATCTACGAGGAGACCCGCGGCGTCCTCAAGATCTTCCTCGAGAACGTCATCCGCGACGCCGTCACCTACACCGAGCACGCCCGCCGCAAAACCGTCACCGCCATGGACGTCGTCTACGCGCTCAAGCGCCAGGGCCGCACCCTCTACGGCTTCGGAGGCTAGATTTGTGTGGTGAAGCAACTTCCTCGTTTGCTCTGTGATCTGTGCT---GTCGTAGATGAGATTTACTGATTTGGCGTGCGCCGGTTGTATTCTGTCA-TGGGGTTCAGTGGGCTGTGTAATACCTTGCTCTGTACTTCTGTTCAATGCAATCACTTCT---ATTCTGAA-------------------------------------";

my $al_seq2 = "TCTAGAGATGGCGCCATTTGATTCCAGCAGCCACAAAGCACTAGAACAATCGATGCTAAGAGGTGACAGGAAAAACAGGCTGCAAAGACCCAGACAATGGAATGCAGCGGTGGTCAGCCTAAAACACTGTAGAAGGGCAAGATGAGCTGAGTAATTTTTAACTGGGCATCATTTTTAGAAACTGGAGTTTAAGTACCCCC--TTTTCCATTTTTTCCTGAAGTCGTGGGCAGGGCGCAAGGTCTGTGAATCGGCCGACCGGATGCAGCTGGTGTGGAGAGTTCCCAATCAGGTCCGATTTATTACTATATAAAGTACTGCTGCGAGGCTTGCCG--TGTTGCATTTTGTTTAGTACAAGACATGTCTGGGCGCGGCAAAGGCGGGAAGGGTCTGGGCAAAGGAGGCGCTAAGCGCCACCGCAAAGTTCTGCGCGACAACATTCAGGGCATCACCAAGCCCGCCATCCGACGCCTGGCACGGCGTGGAGGCGTTAAGCGCATCTCAGGCCTTATATACGAGGAGACACGCGGAGTTCTTAAAGTGTTTTTGGAGAATGTAATCCGCGATGCAGTTACCTACACGGAGCACGCCAAACGCAAGACAGTCACAGCCATGGACGTGGTTTACGCGCTCAAGCGCCAGGGCCGCACCCTGTATGGCTTTGGCGGC------TGAGTGTTTTACTTACTTACACGGTTCCTCAAAGGCCCTTCTCAGGGCCACCCATGAAGTCTGTGAAAGAGCTGTAGACTAAAGATAGTTAATTTCTTAAGAACACTTAAACGTATGGCAGTTTTGGCAAATTAGCGATTCCACATAAGCAGTCGCTGAAGTTTGAGGTTCGGTGCCCCTTTCAGCATTACTTAGTGGTTAAAA";

my $size = length($al_seq1);

my @seq1 = split(//,$al_seq1);
my @seq2 = split(//,$al_seq2);

print "$al_seq1\n";
print "$al_seq2\n";
for(my $i = 0; $i < $size; $i++)
{
  if ($seq1[$i] ne $seq2[$i])
  {
    print "Difference at $i\n";
  }
}
+---------------------------+

11b. Do the same as above but instead of coping and pasting into string variables
import from a file.
 
+---------------------------+
#!/usr/bin/perl
# File: alignmentFile.pl
# Author: Steven Ahrendt

use strict;
use warnings;


## Use the fasta parser from Perl III, problem 3
#   but modified so that the sequences are stored in an array

my $alignment_file = shift @ARGV;

open(ALN,"<",$alignment_file) or die "Can't open file $alignment_file: $!\n";
my @aln_array;
my $header;
my $sequence = '';

while (my $line = <IN>)
{
  chomp($line);

  ## There are many ways to check for a '>' character
  #   - pattern matching, using the =~ operator
  #   - substring, using the substr() function
  #   - index, using the index() function
  ## Here, I use substring:
  my $char = substr($line,0,1);
  if ($char eq ">")
  {
    ## This is a fasta header line, but it could be the first of the file
    #    or it could be somewhere in the middle of the file. To check,
    #    we can look at the length of $sequence
    if (length($sequence) > 0)
    {
      ## This means we have accumulated a complete fasta entry
      #   store it:
      push(@aln_array,$sequence);

      #  and clear the variable for the next sequence:
      $sequence = '';
    }
    # This stores the contents of $line in the $header variable
    $header = $line; # header is updated with current sequence name
  }
  else
  {
    ## If we're here, that means we've just hit some sequence line
    #   so we can grow our $sequence by adding $lines to it using the
    #   concatenate operator '.'
    $sequence = $line.$sequence;
  }
}

## After we've processed the file, we still have some sequence left, so we need to store that too
if (length($sequence) > 0)
{
  push(@aln_array,$sequence);
}

close(ALN);

## The rest of the program is nearly identical to problem 10
my $size = length($aln_array[0]);

my @seq1 = split(//,$aln_array[0]);
my @seq2 = split(//,$aln_array[1]);

print "$aln_array[0]\n";
print "$aln_array[1]\n";
for(my $i = 0; $i < $size; $i++)
{
  if ($seq1[$i] ne $seq2[$i])
  {
    print "Difference at $i\n";
  }
}
+---------------------------+
